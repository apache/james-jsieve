/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2004 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache", "Jakarta", "JAMES", "JSieve" and 
 *    "Apache Software Foundation" must not be used to endorse or promote
 *    products derived from this software without prior written permission.
 *    For written permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */
options {
  MULTI=true;
  VISITOR=true;
  VISITOR_EXCEPTION="org.apache.jsieve.SieveException";
  NODE_DEFAULT_VOID=false;
  STATIC = false;
  JAVA_UNICODE_ESCAPE = true;  
  DEBUG_PARSER = false;
  OUTPUT_DIRECTORY="./org/apache/jsieve/parser";  
}

PARSER_BEGIN(SieveParser)

package org.apache.jsieve.parser;

import org.apache.jsieve.*;

public class SieveParser { }

PARSER_END(SieveParser)

/*****************************************
 * THE SIEVE LANGUAGE TOKENS STARTS HERE *
 *****************************************/

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <HASH_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| 
  <BRACKET_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* Can't make this one special */
{
  <EOF_HASH_COMMENT: "#" (~["\n","\r"])*>
}              


// identifier = (ALPHA / "_") *(ALPHA DIGIT "_")
TOKEN : /* IDENTIFIER */
{
   <IDENTIFIER: (<ALPHA>|"_") (<ALPHA>|<DIGIT>|"_")*>
|
  < #ALPHA:
      [
       "\u0041"-"\u005a",
       "\u0061"-"\u007a"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"
      ]
  >  
}

// tag = ":" identifier
TOKEN : /* TAG */
{
   <TAG: ":" <IDENTIFIER> >
}

TOKEN : /* LITERALS */
{
// number = 1*DIGIT [QUANTIFIER]
// QUANTIFIER = "K" / "M" / "G"
   < NUMBER: 
       <DECIMAL_LITERAL> (<QUANTIFIER>)?
   >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #QUANTIFIER: ["K","M","G"] >    
|
// quoted-string = DQUOTE *CHAR DQUOTE
// in general, \ CHAR inside a string maps to CHAR
// so \" maps to " and \\ maps to \
// note that newlines and other characters are all allowed strings
  < QUOTED_STRING:
      "\""
      (~["\""])*
      "\""
  >
|
// multi-line = "text:" *(SP / HTAB) (hash-comment / CRLF)
//               *(multi-line-literal / multi-line-dotstuff)
//               "." CRLF
// Hmm. What we need to do is treat (CRLF / LF / CR) as <NEWLINE> throughout
  < MULTI_LINE:
      <MULTI_LINE_START>
      (<MULTI_LINE_LITERAL> |<MULTI_LINE_DOTSTUFF>)*
      <MULTI_LINE_END>
  >
|
  <#MULTI_LINE_START: 
      ("text:")
      ([" ", "\t"])*
      (<HASH_COMMENT>|<NEWLINE>)
  >
|
  <#MULTI_LINE_END:
      ("." <NEWLINE>)
  >              
|
  <#NEWLINE:
      ("\n"|"\r"|"\r\n")
  >
|                           
// multi-line-literal  = [CHAR-NOT-DOT *CHAR_NOT_NEWLINE] NEWLINE 
  < #MULTI_LINE_LITERAL:
      (<CHAR_NOT_DOT> (<CHAR_NOT_NEWLINE>)*)?
      <NEWLINE>
  >  
|
  < #CHAR_NOT_DOT: 
      (~["."])
  >
|
  < #CHAR_NOT_NEWLINE: 
      (~["\n"] | ("\r" ~["\n"]))
  >   
|
// multi-line-dotstuff = "." 1*CHAR-NOT-CRLF CRLF
// A line containing only "." ends the multi-line.
// Remove a leading '.' if followed by another '.'.
  < #MULTI_LINE_DOTSTUFF:
    "."
    (<CHAR_NOT_NEWLINE>)+
    <NEWLINE>
  >  
}

/******************************************
 * THE SIEVE LANGUAGE GRAMMAR STARTS HERE *
 ******************************************/

// start = commands   
SimpleNode start() :
{  }
{
  commands()
  (<EOF_HASH_COMMENT>)? // Allow a Hash comment immediately prior to EOF
  <EOF>
  { return jjtThis; }  
}

//   commands = *command
void commands() :
{ }
{
  (command())*
}

//   command = identifier arguments ( ";" / block )
void command() :
{ Token identifier = null; }
{
  (identifier = <IDENTIFIER>) arguments() (";" | block())
  {
    jjtThis.setName(identifier.image);
  }  
}

//   block = "{" commands "}"
void block() :
{ }
{
   "{" commands() "}"
}

//   arguments = *argument [test / test-list]
void arguments() :
{ }
{
  (argument())* (test() | test_list())?
}

//    argument = string-list / number / tag
void argument() :
{ Token string_list = null, number = null, tag = null; }
{
  (string_list() | number = <NUMBER> | tag = <TAG>)
  {
    Argument value = null; 
    if (null != number)
       value = new NumberArgument(number);
    else if (null != tag)
       value = new TagArgument(tag);
    jjtThis.setValue(value);       
  }
}

//   test = identifier arguments
void test() :
{ Token identifier = null; }
{
  (identifier = <IDENTIFIER> arguments())
  {
    jjtThis.setName(identifier.image);
  }   
}

//   test-list = "(" test *("," test) ")"
void test_list() :
{ }
{
  "(" test() ("," test())* ")"
}

//   string = quoted-string / multi-line
void string() :
{ Token quoted_string = null, multi_line = null;}
{
  (quoted_string = <QUOTED_STRING> | multi_line = <MULTI_LINE>)
  {
    if (null != quoted_string)
      jjtThis.setValue(quoted_string.image);
    else if (null != multi_line)
      jjtThis.setValue(multi_line.image);  
  }
}

//   string-list = "[" string *("," string) "]" / string         ;; if
//   there is only a single string, the brackets are optional
void string_list() :
{ }
{
  ("[" string() ("," string())* "]") | string()
}


   
 